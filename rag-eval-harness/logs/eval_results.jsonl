{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 10572.9, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7254.2, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 10149.4, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7425.4, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 8236.3, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 9433.1, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 10952.0, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 9486.4, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7974.6, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for handling millions of vectors efficiently, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7264.5, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7511.0, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7145.1, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 6925.7, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7369.0, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 8137.1, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"]}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 9103.2, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors, achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 6420.3, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "OK"}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for handling millions of vectors efficiently and achieving high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 6913.9, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7048.7, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is a high-performance, open-source vector database written in Rust, designed for real-time applications that require fast and accurate similarity search on large datasets. It utilizes the HNSW algorithm (Hierarchical Navigable Small World graphs) for approximate nearest neighbor (ANN) search, which is optimized for high-dimensional data and can efficiently handle millions of vectors with high queries-per-second throughput [source1__0004].\n\nQdrant stores vectors along with associated JSON payloads (metadata), allowing for filtering of search results based on these fields without significant performance degradation. This feature, known as \"filterable HNSW,\" enhances the database's capability to manage and retrieve data effectively [source1__0004].", "retrieved_chunk_ids": ["source1__0004", "source1__0080", "source1__0048", "source1__0007", "source1__0058"], "latency_ms": 7455.4, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Why Qdrant?\nThere are many vector databases out there – so why choose Qdrant? Qdrant (pronounced “quadrant”) is a high-p", "ures – Qdrant Cloud provides encryption and authentication keys. For self-host, you might want to run it behind a firewa", "Comparison with Other Vector Databases\nIt’s a booming field, and Qdrant isn’t alone. How does Qdrant stack up against so", "+ open-source freedom”.\nWhen does Qdrant shine? When you need a balance of top-notch performance, filtering, and ease of", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a powerful, open-source vector search engine designed for applications that require semantic understanding of data at scale. It excels in scenarios like semantic search, real-time recommendations, and LLM augmentation, providing fast and filterable results. Qdrant allows for dynamic data handling and offers an accessible API for developers, making it suitable for production-ready AI systems.", "retrieved_chunk_ids": ["source1__0021", "source1__0005", "source1__0026", "source1__0006", "source1__0056"], "latency_ms": 7078.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "UNGROUNDED"}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant stores data by embedding documents into vectors using models like SentenceTransformers or OpenAI’s embeddings. These vectors are stored in a Qdrant collection along with payloads that include the original text and possibly metadata such as titles or sources. It is recommended to store identifiers and short snippets in the payload rather than large blobs of text to avoid bloating the database.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0036", "source1__0027"], "latency_ms": 6272.6, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "ystems also do a second vector search using parts of the initial answer to find more info (feedback loop). Qdrant can ha"], "bucket": "UNGROUNDED"}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "A collection in Qdrant is like a table in a relational database; it holds a set of vectors (called 'points' in Qdrant terminology) with the same configuration. When creating a collection, you specify the vector size (dimensionality) and the distance metric to use for similarity.", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0009", "source1__0006", "source1__0020"], "latency_ms": 5820.9, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel"], "bucket": "UNGROUNDED"}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Similarity in Qdrant is typically measured using a similarity score or distance metric, such as cosine similarity or dot product. When querying for nearest neighbors, Qdrant returns a list of scored points, each with an ID and a similarity score that indicates how close the points are to the queried vector.", "retrieved_chunk_ids": ["source1__0013", "source1__0028", "source1__0052", "source1__0015", "source1__0031"], "latency_ms": 5890.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly "], "bucket": "UNGROUNDED"}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is used for serious applications such as semantic search, where it helps in retrieving relevant pieces of text from documents based on user queries. It excels in scenarios requiring real-time recommendations, anomaly detection on streaming data, and handling dynamic data with low latency. Additionally, it is suitable for building semantic search engines by embedding documents into vectors and storing them for efficient retrieval.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0005", "source1__0006", "source1__0053"], "latency_ms": 7455.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or"], "bucket": "UNGROUNDED"}
{"test_id": "q06", "question": "What algorithm does Qdrant use for similarity search?", "expected_points": ["HNSW", "approximate nearest neighbor search"], "answer": "INSUFFICIENT_CONTEXT", "retrieved_chunk_ids": ["source1__0021", "source1__0052", "source1__0024", "source1__0028", "source1__0013"], "latency_ms": 4825.7, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q07", "question": "What are points in Qdrant composed of?", "expected_points": ["vector", "payload"], "answer": "Points in Qdrant are composed of vectors and payloads. The vectors are typically embeddings generated from documents or queries, while the payloads can include the original text and additional metadata such as titles or sources.", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0020", "source1__0013", "source1__0054"], "latency_ms": 6891.5, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "UNGROUNDED"}
{"test_id": "q08", "question": "What can payload in Qdrant store?", "expected_points": ["metadata", "filters"], "answer": "In Qdrant, the payload can store associated JSON metadata for each vector, which may include the actual text, identifiers, and additional information like titles or sources. However, it is advised not to store large blobs of text directly in the payload, as this can bloat the database and slow down network responses.", "retrieved_chunk_ids": ["source1__0053", "source1__0021", "source1__0026", "source1__0052", "source1__0003"], "latency_ms": 7523.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN"], "bucket": "UNGROUNDED"}
{"test_id": "q09", "question": "Why use a vector database like Qdrant?", "expected_points": ["semantic search", "embeddings based retrieval"], "answer": "Qdrant is a high-performance, open-source vector database designed for real-time applications that require fast and accurate similarity search on large datasets. It excels in scenarios like semantic search, RAG pipelines, and recommendations, where traditional databases struggle. Qdrant offers advanced features such as HNSW tuning and efficient filtering, making it suitable for applications where performance and scale are critical.", "retrieved_chunk_ids": ["source1__0021", "source1__0002", "source1__0032", "source1__0050", "source1__0036"], "latency_ms": 6274.6, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Traditional databases (SQL, NoSQL, etc.) struggle with this task – they aren’t optimized for the math of high-dimensiona", "– essentially any time you can represent something as a vector and you want to find similar ones, a vector DB is your fr", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q10", "question": "How do you choose a distance metric in Qdrant?", "expected_points": ["cosine", "Euclidean or dot"], "answer": "When creating a collection in Qdrant, you choose a distance metric that matches how your embeddings were trained. Qdrant supports popular metrics such as cosine, dot product, and Euclidean (L2) distance. The choice of metric should align with the similarity measure used during the training of your model, for example, if you used cosine similarity in model training, you should use cosine in Qdrant.", "retrieved_chunk_ids": ["source1__0005", "source1__0009", "source1__0036", "source1__0003", "source1__0021"], "latency_ms": 6293.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q11", "question": "How can you filter search results in Qdrant?", "expected_points": ["payload filter", "field conditions"], "answer": "You can filter search results in Qdrant by using payload filtering, which allows you to specify conditions that the results must meet. For example, you can add a filter to your search query to only return vectors that match certain criteria, such as a specific city or category. This is done by constructing a Filter with conditions like FieldCondition and MatchValue, which can be combined to refine the search results further.", "retrieved_chunk_ids": ["source1__0021", "source1__0024", "source1__0016", "source1__0003", "source1__0026"], "latency_ms": 5999.9, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q12", "question": "What is the purpose of a payload index?", "expected_points": ["faster filtering", "index on payload field"], "answer": "A payload index in Qdrant is used to create a structured index (like a b-tree or inverted index) on payload data to speed up filters. This can dramatically improve filtered query latency and reduce CPU usage, at the cost of some RAM to hold the index.", "retrieved_chunk_ids": ["source1__0026", "source1__0053", "source1__0052", "source1__0016", "source1__0023"], "latency_ms": 6479.0, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q13", "question": "What languages or APIs does Qdrant support?", "expected_points": ["REST API", "Python client (others)"], "answer": "Qdrant supports multiple programming languages including Python, TypeScript/JavaScript, Go, Java, and Rust. It also offers both RESTful HTTP API and gRPC API for flexible integrations.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0004", "source1__0005", "source1__0056"], "latency_ms": 5610.9, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "arity with keyword search by allowing sparse vectors (like TF-IDF or BM25 weights) in the same index‍. This gives you th", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q14", "question": "How does Qdrant handle updates to vectors?", "expected_points": ["upsert", "reindex existing ID"], "answer": "Qdrant allows for updating vectors by re-embedding some text with a new model or deleting vectors when necessary, such as removing a discontinued product from recommendations. This flexibility enables applications to adapt to changing data while maintaining performance.", "retrieved_chunk_ids": ["source1__0054", "source1__0021", "source1__0017", "source1__0005", "source1__0050"], "latency_ms": 5127.1, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q15", "question": "What does similarity search return?", "expected_points": ["nearest neighbors", "score or distance"], "answer": "Similarity search returns a list of scored points, each with an ID, the similarity score (or distance), and any payload if requested. This allows users to find the most similar points in the collection based on a new vector, such as an embedding of a user query or an item.", "retrieved_chunk_ids": ["source1__0023", "source1__0015", "source1__0013", "source1__0052", "source1__0026"], "latency_ms": 6020.7, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q16", "question": "What type of database is Qdrant categorized as?", "expected_points": ["open-source", "vector database"], "answer": "Qdrant is categorized as a vector database, which is designed for handling vector similarity search and related applications.", "retrieved_chunk_ids": ["source1__0021", "source1__0036", "source1__0058", "source1__0057", "source1__0040"], "latency_ms": 4891.6, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "t significant cost and loss of open-source freedom.\n\nIn our experience, though, Qdrant is a fantastic middle ground for ", "And when might Qdrant not be ideal? If your use case is very small or simple, and you don’t want any external service, a", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "UNGROUNDED"}
{"test_id": "q17", "question": "Can Qdrant be run embedded in a script?", "expected_points": ["embedded mode", "in-memory or file-based"], "answer": "INSUFFICIENT_CONTEXT", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0006", "source1__0054"], "latency_ms": 4467.6, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q18", "question": "What are common use cases for Qdrant?", "expected_points": ["RAG", "recommendations"], "answer": "Common use cases for Qdrant include semantic search, where it helps return relevant text even if the words don't match exactly; anomaly detection for identifying outliers in data; multimedia search for finding similar images or audio; and hybrid filtering based on user preferences, allowing for geographic and similarity searches. Additionally, it can be used for storing graph data as vectors to find related entities.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0031", "source1__0053", "source1__0056"], "latency_ms": 6235.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly ", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "UNGROUNDED"}
{"test_id": "q19", "question": "What must all vectors in a Qdrant collection share?", "expected_points": ["same dimension", "same metric"], "answer": "All vectors in a Qdrant collection must share the same configuration, which includes the vector size (dimensionality) and the distance metric used for similarity.", "retrieved_chunk_ids": ["source1__0021", "source1__0009", "source1__0050", "source1__0054", "source1__0052"], "latency_ms": 5366.9, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q20", "question": "How does filtering improve search?", "expected_points": ["refine results", "business constraints"], "answer": "Filtering improves search by allowing users to narrow down results based on specific conditions, such as category or attributes like date and location. This ensures that the search results are more relevant and targeted, as it eliminates irrelevant matches while still leveraging semantic similarity. For example, filtering can help retrieve only items from a certain city or within a specific date range, enhancing the quality of the results.", "retrieved_chunk_ids": ["source1__0016", "source1__0023", "source1__0024", "source1__0026", "source1__0017"], "latency_ms": 5976.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a powerful, open-source vector search engine designed for applications that require semantic understanding of data at scale. It excels in scenarios like semantic search, LLM augmentation, and real-time recommendations, offering high performance, flexibility, and an accessible API for developers. Qdrant allows for dynamic data handling and advanced filtering, making it suitable for production AI systems.", "retrieved_chunk_ids": ["source1__0021", "source1__0005", "source1__0026", "source1__0006", "source1__0056"], "latency_ms": 6688.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "UNGROUNDED"}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant stores data by embedding documents into vectors using models like SentenceTransformers or OpenAI’s embeddings. These vectors are stored in a Qdrant collection along with payloads that include the original text and possibly metadata such as titles or sources. It is recommended to store identifiers and short snippets in the payload rather than large blobs of text to avoid bloating the database.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0027", "source1__0036"], "latency_ms": 6566.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "ystems also do a second vector search using parts of the initial answer to find more info (feedback loop). Qdrant can ha", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "UNGROUNDED"}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "A collection in Qdrant is like a table in a relational database, holding a set of vectors (referred to as 'points') with the same configuration. When creating a collection, you specify the vector size and the distance metric to use for similarity, such as cosine, dot product, or Euclidean distance.", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0009", "source1__0006", "source1__0020"], "latency_ms": 6138.9, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel"], "bucket": "UNGROUNDED"}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Similarity in Qdrant is typically measured using a similarity score or distance metric, such as cosine similarity or dot product. When querying for nearest neighbors, Qdrant returns a list of scored points, each with an ID and a similarity score that indicates how similar the points are to the query vector.", "retrieved_chunk_ids": ["source1__0013", "source1__0028", "source1__0052", "source1__0015", "source1__0031"], "latency_ms": 6545.2, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly "], "bucket": "UNGROUNDED"}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is used for serious applications such as semantic search, real-time recommendations, and anomaly detection on streaming data. It excels in scenarios where speed and accuracy are paramount, allowing users to build semantic search engines that return relevant text even when the words don't match exactly. Additionally, it can handle dynamic data, enabling the addition and updating of vectors on the fly while serving queries with low latency.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0005", "source1__0006", "source1__0053"], "latency_ms": 6135.5, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or"], "bucket": "UNGROUNDED"}
{"test_id": "q06", "question": "What algorithm does Qdrant use for similarity search?", "expected_points": ["HNSW", "approximate nearest neighbor search"], "answer": "INSUFFICIENT_CONTEXT", "retrieved_chunk_ids": ["source1__0021", "source1__0052", "source1__0024", "source1__0028", "source1__0013"], "latency_ms": 4915.6, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q07", "question": "What are points in Qdrant composed of?", "expected_points": ["vector", "payload"], "answer": "Points in Qdrant are composed of vectors and payloads. The vectors are typically embeddings generated from documents or queries, while the payloads can include the original text and additional metadata such as titles or sources.", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0020", "source1__0013", "source1__0054"], "latency_ms": 5125.2, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "UNGROUNDED"}
{"test_id": "q08", "question": "What can payload in Qdrant store?", "expected_points": ["metadata", "filters"], "answer": "In Qdrant, the payload can store associated metadata in JSON format, which may include the actual text of the document, identifiers, and additional information like titles or sources. However, it is advised not to store large blobs of text directly in the payload, as this can bloat the database and slow down network responses.", "retrieved_chunk_ids": ["source1__0053", "source1__0021", "source1__0026", "source1__0052", "source1__0003"], "latency_ms": 5809.3, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN"], "bucket": "UNGROUNDED"}
{"test_id": "q09", "question": "Why use a vector database like Qdrant?", "expected_points": ["semantic search", "embeddings based retrieval"], "answer": "Qdrant is a high-performance, open-source vector database designed for real-time applications that require fast and accurate similarity search on large datasets. It excels in scenarios like semantic search, RAG pipelines, and recommendations, where traditional databases struggle. Qdrant offers advanced features such as HNSW tuning and product quantization, making it suitable for applications where performance and scale are critical.", "retrieved_chunk_ids": ["source1__0021", "source1__0002", "source1__0032", "source1__0050", "source1__0036"], "latency_ms": 6917.5, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Traditional databases (SQL, NoSQL, etc.) struggle with this task – they aren’t optimized for the math of high-dimensiona", "– essentially any time you can represent something as a vector and you want to find similar ones, a vector DB is your fr", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q10", "question": "How do you choose a distance metric in Qdrant?", "expected_points": ["cosine", "Euclidean or dot"], "answer": "When creating a collection in Qdrant, you choose a distance metric that matches how your embeddings were trained. Qdrant supports popular metrics such as cosine, dot product, and Euclidean (L2) distance. The choice of metric should align with the similarity measure used during the training of your model, for example, if you used cosine similarity in model training, you should use cosine in Qdrant.", "retrieved_chunk_ids": ["source1__0005", "source1__0009", "source1__0036", "source1__0003", "source1__0021"], "latency_ms": 6068.0, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q11", "question": "How can you filter search results in Qdrant?", "expected_points": ["payload filter", "field conditions"], "answer": "You can filter search results in Qdrant by using payload filtering, which allows you to specify conditions that the results must meet. For example, you can add a filter to your search query to only return vectors that match certain criteria, such as a specific city or category. This is done by constructing a Filter with conditions like FieldCondition and MatchValue, which can be combined to refine the search results further.", "retrieved_chunk_ids": ["source1__0021", "source1__0024", "source1__0016", "source1__0003", "source1__0026"], "latency_ms": 6377.5, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q12", "question": "What is the purpose of a payload index?", "expected_points": ["faster filtering", "index on payload field"], "answer": "A payload index in Qdrant is used to create a structured index (like a b-tree or inverted index) on payload data to speed up filters. This can dramatically improve filtered query latency and reduce CPU usage, at the cost of some RAM to hold the index.", "retrieved_chunk_ids": ["source1__0026", "source1__0053", "source1__0052", "source1__0016", "source1__0023"], "latency_ms": 5367.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q13", "question": "What languages or APIs does Qdrant support?", "expected_points": ["REST API", "Python client (others)"], "answer": "Qdrant supports multiple programming languages through client libraries, including Python, TypeScript/JS, Go, Java, and Rust. It also offers both RESTful HTTP API and gRPC API for flexible integrations.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0004", "source1__0056", "source1__0005"], "latency_ms": 5593.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "arity with keyword search by allowing sparse vectors (like TF-IDF or BM25 weights) in the same index‍. This gives you th", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q14", "question": "How does Qdrant handle updates to vectors?", "expected_points": ["upsert", "reindex existing ID"], "answer": "Qdrant allows for updating vectors by re-embedding some text with a new model or deleting vectors when necessary, such as removing a discontinued product from recommendations. This flexibility enables applications to adapt to changing data while maintaining performance.", "retrieved_chunk_ids": ["source1__0054", "source1__0021", "source1__0017", "source1__0005", "source1__0050"], "latency_ms": 6418.2, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q15", "question": "What does similarity search return?", "expected_points": ["nearest neighbors", "score or distance"], "answer": "Similarity search returns a list of scored points, each with an ID, the similarity score (or distance), and any payload if requested. This allows users to find the most similar points in the collection based on a new vector, such as an embedding of a user query or an item.", "retrieved_chunk_ids": ["source1__0023", "source1__0015", "source1__0013", "source1__0052", "source1__0026"], "latency_ms": 5956.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q16", "question": "What type of database is Qdrant categorized as?", "expected_points": ["open-source", "vector database"], "answer": "Qdrant is categorized as a vector database, which is designed for handling vector similarity search and related applications.", "retrieved_chunk_ids": ["source1__0021", "source1__0036", "source1__0058", "source1__0057", "source1__0040"], "latency_ms": 5041.3, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "t significant cost and loss of open-source freedom.\n\nIn our experience, though, Qdrant is a fantastic middle ground for ", "And when might Qdrant not be ideal? If your use case is very small or simple, and you don’t want any external service, a", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "UNGROUNDED"}
{"test_id": "q17", "question": "Can Qdrant be run embedded in a script?", "expected_points": ["embedded mode", "in-memory or file-based"], "answer": "INSUFFICIENT_CONTEXT", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0006", "source1__0054"], "latency_ms": 4644.8, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q18", "question": "What are common use cases for Qdrant?", "expected_points": ["RAG", "recommendations"], "answer": "Common use cases for Qdrant include semantic search, where it helps return relevant text even if the words don't match exactly; anomaly detection for identifying outliers in data; multimedia search for finding similar images or audio; and hybrid filtering based on user preferences, allowing for geographic and similarity searches. Additionally, it can be used for storing graph data as vectors to find related entities.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0031", "source1__0053", "source1__0056"], "latency_ms": 6112.7, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly ", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "UNGROUNDED"}
{"test_id": "q19", "question": "What must all vectors in a Qdrant collection share?", "expected_points": ["same dimension", "same metric"], "answer": "All vectors in a Qdrant collection must share the same configuration, which includes the vector size (dimensionality) and the distance metric used for similarity.", "retrieved_chunk_ids": ["source1__0021", "source1__0009", "source1__0050", "source1__0054", "source1__0052"], "latency_ms": 5528.5, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q20", "question": "How does filtering improve search?", "expected_points": ["refine results", "business constraints"], "answer": "Filtering improves search by allowing users to narrow down results based on specific conditions, such as category or attributes like date and location. This ensures that the search results are more relevant and targeted, as it eliminates irrelevant matches while still leveraging semantic similarity. For example, filtering can help retrieve only items from a certain city or within a specific date range, enhancing the quality of the results.", "retrieved_chunk_ids": ["source1__0016", "source1__0023", "source1__0024", "source1__0026", "source1__0017"], "latency_ms": 6536.5, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a powerful vector search engine designed for applications that require semantic understanding of data at scale. It excels in scenarios such as semantic search, where it can return relevant text pieces even if the words do not exactly match the user's query. Qdrant is known for its performance, flexibility, and ease of integration, making it suitable for production-ready applications like real-time recommendations, anomaly detection, and LLM augmentation. It is open-source, allowing users to run it anywhere without incurring hefty vendor fees, and it supports advanced filtering capabilities to combine vector similarity with other conditions [source1__0021][source1__0056].", "retrieved_chunk_ids": ["source1__0021", "source1__0005", "source1__0026", "source1__0006", "source1__0056"], "latency_ms": 8109.3, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "OK"}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant stores data by embedding documents into vectors using models like SentenceTransformers or OpenAI’s embeddings. These vectors are then stored in a Qdrant collection along with payloads that include the original text and possibly metadata such as title or source. It is recommended to store identifiers and short snippets in the payload rather than large blobs of text to avoid bloating the database and slowing down network responses. For example, one might store a document ID and a summary sentence in Qdrant, while retrieving the full article text from a separate storage solution like S3 when needed [source1__0053].", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0027", "source1__0036"], "latency_ms": 11193.8, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "ystems also do a second vector search using parts of the initial answer to find more info (feedback loop). Qdrant can ha", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "OK"}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "A collection in Qdrant is like a table in a relational database; it holds a set of vectors (called “points” in Qdrant terminology) with the same configuration. When creating a collection, you specify the vector size (dimensionality) and the distance metric to use for similarity, such as cosine, dot product, or Euclidean (L2) distance. This structure allows for organized storage and retrieval of embedded data [source1__0009].", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0009", "source1__0006", "source1__0020"], "latency_ms": 7342.2, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel"], "bucket": "OK"}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Similarity in Qdrant is typically measured using distance metrics such as cosine similarity or dot product. When querying for nearest neighbors, Qdrant returns a list of scored points, each with an ID and a similarity score (or distance) based on these metrics. The scores indicate how similar the queried vector is to the stored vectors in the collection, with values reflecting the degree of similarity or distance between them [source1__0015].", "retrieved_chunk_ids": ["source1__0013", "source1__0028", "source1__0052", "source1__0015", "source1__0031"], "latency_ms": 6267.5, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly "], "bucket": "OK"}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is used for serious applications such as semantic search, real-time recommendations, and anomaly detection on streaming data. It excels in scenarios where speed and accuracy are paramount, allowing users to build semantic search engines that return relevant text pieces even when the words don't exactly match. Qdrant can handle dynamic data, enabling the addition and updating of vectors on the fly while serving queries with low latency [source1__0021][source1__0005].", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0005", "source1__0006", "source1__0053"], "latency_ms": 6370.0, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or"], "bucket": "OK"}
{"test_id": "q06", "question": "What algorithm does Qdrant use for similarity search?", "expected_points": ["HNSW", "approximate nearest neighbor search"], "answer": "I don't know.", "retrieved_chunk_ids": ["source1__0021", "source1__0052", "source1__0024", "source1__0028", "source1__0013"], "latency_ms": 4237.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q07", "question": "What are points in Qdrant composed of?", "expected_points": ["vector", "payload"], "answer": "Points in Qdrant are composed of vectors and payloads. The vectors are typically embeddings generated from documents or queries, while the payloads can include the original text and additional metadata, such as titles or sources [source1__0021].", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0020", "source1__0013", "source1__0054"], "latency_ms": 5207.4, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "OK"}
{"test_id": "q08", "question": "What can payload in Qdrant store?", "expected_points": ["metadata", "filters"], "answer": "Payload in Qdrant can store metadata associated with each vector, such as the actual text, identifiers, and possibly additional information like titles or sources. It is recommended to store concise data, like a summary or an identifier, rather than large blobs of text, as Qdrant is not designed for large blob storage. For example, you might store a document ID and a short snippet in the payload, while keeping the full data in a separate storage solution like an object storage or a database [source1__0053].", "retrieved_chunk_ids": ["source1__0053", "source1__0021", "source1__0026", "source1__0052", "source1__0003"], "latency_ms": 6531.7, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN"], "bucket": "OK"}
{"test_id": "q09", "question": "Why use a vector database like Qdrant?", "expected_points": ["semantic search", "embeddings based retrieval"], "answer": "You should use a vector database like Qdrant because it is optimized for high-dimensional vector mathematics, enabling fast and accurate similarity searches on large datasets. Qdrant excels in scenarios such as semantic search, where it can return relevant documents based on concepts rather than exact keywords, making it ideal for applications like knowledge bases and recommendation systems. Additionally, it supports advanced features like HNSW tuning and product quantization, which enhance performance and scalability. Qdrant is particularly beneficial when building AI features that are core to your product, as it provides reliability and speed that traditional databases cannot match [source1__0021][source1__0036].", "retrieved_chunk_ids": ["source1__0021", "source1__0002", "source1__0032", "source1__0050", "source1__0036"], "latency_ms": 7029.2, "format_valid": true, "citation_count": 2, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Traditional databases (SQL, NoSQL, etc.) struggle with this task – they aren’t optimized for the math of high-dimensiona", "– essentially any time you can represent something as a vector and you want to find similar ones, a vector DB is your fr", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q10", "question": "How do you choose a distance metric in Qdrant?", "expected_points": ["cosine", "Euclidean or dot"], "answer": "You choose a distance metric in Qdrant by specifying the metric that matches how your embeddings were trained. Qdrant supports popular metrics such as cosine, dot product, and Euclidean (L2) distance. For example, if you used cosine similarity during model training, you would use cosine in Qdrant as well [source1__0009].", "retrieved_chunk_ids": ["source1__0005", "source1__0009", "source1__0036", "source1__0003", "source1__0021"], "latency_ms": 6180.9, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q11", "question": "How can you filter search results in Qdrant?", "expected_points": ["payload filter", "field conditions"], "answer": "You can filter search results in Qdrant by using payload filtering. Each vector in Qdrant can have an associated JSON payload (metadata), and you can specify conditions to filter the search results based on these fields. For example, you can create a filter that requires certain conditions to be met, such as matching a specific value in a payload field. \n\nHere’s an example of how to filter results to only include vectors where the city is \"London\":\n\n```python\nfrom qdrant_client.models import Filter, FieldCondition, MatchValue\n\nresults = client.search(\n    collection_name=\"my_collection\",\n    query_vector=query_vector,\n    query_filter=Filter(\n        must=[FieldCondition(key=\"city\", match=MatchValue(value=\"London\"))]\n    ),\n    limit=3,\n    with_payload=True\n)\n```\n\nIn this case, the filter specifies that the point’s payload must have the city matching \"London\". You can combine multiple conditions using the `must`, `should`, and `must_not` lists for more complex queries. Qdrant supports various conditions, including exact matches and range queries for numeric values, among others [source1__0016].", "retrieved_chunk_ids": ["source1__0021", "source1__0024", "source1__0016", "source1__0003", "source1__0026"], "latency_ms": 9110.6, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q12", "question": "What is the purpose of a payload index?", "expected_points": ["faster filtering", "index on payload field"], "answer": "A payload index in Qdrant is used to create a structured index (like a b-tree or inverted index) on payload data to speed up filters. This can dramatically improve filtered query latency and reduce CPU usage, at the cost of some RAM to hold the index [source1__0052].", "retrieved_chunk_ids": ["source1__0026", "source1__0053", "source1__0052", "source1__0016", "source1__0023"], "latency_ms": 5394.4, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q13", "question": "What languages or APIs does Qdrant support?", "expected_points": ["REST API", "Python client (others)"], "answer": "Qdrant supports both RESTful HTTP API and gRPC API out of the box, along with client libraries in multiple languages including Python, TypeScript/JS, Go, Java, and Rust [source1__0004].", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0004", "source1__0005", "source1__0056"], "latency_ms": 4940.6, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "arity with keyword search by allowing sparse vectors (like TF-IDF or BM25 weights) in the same index‍. This gives you th", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q14", "question": "How does Qdrant handle updates to vectors?", "expected_points": ["upsert", "reindex existing ID"], "answer": "Qdrant allows for updating vectors by re-embedding some text with a new model or by deleting vectors when necessary, such as removing a discontinued product from recommendations. This flexibility is important for applications that require changes to their data over time [source1__0017].", "retrieved_chunk_ids": ["source1__0054", "source1__0021", "source1__0005", "source1__0017", "source1__0052"], "latency_ms": 5509.0, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q15", "question": "What does similarity search return?", "expected_points": ["nearest neighbors", "score or distance"], "answer": "Similarity search returns a list of scored points, each with an ID, the similarity score (or distance), and any payload if requested [source1__0013].", "retrieved_chunk_ids": ["source1__0023", "source1__0015", "source1__0013", "source1__0052", "source1__0026"], "latency_ms": 4625.5, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q16", "question": "What type of database is Qdrant categorized as?", "expected_points": ["open-source", "vector database"], "answer": "Qdrant is categorized as a vector database [source1__0058].", "retrieved_chunk_ids": ["source1__0021", "source1__0036", "source1__0058", "source1__0057", "source1__0040"], "latency_ms": 5988.5, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "t significant cost and loss of open-source freedom.\n\nIn our experience, though, Qdrant is a fantastic middle ground for ", "And when might Qdrant not be ideal? If your use case is very small or simple, and you don’t want any external service, a", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "OK"}
{"test_id": "q17", "question": "Can Qdrant be run embedded in a script?", "expected_points": ["embedded mode", "in-memory or file-based"], "answer": "I don't know.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0006", "source1__0054"], "latency_ms": 4467.0, "format_valid": true, "citation_count": 0, "citation_coverage": false, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q18", "question": "What are common use cases for Qdrant?", "expected_points": ["RAG", "recommendations"], "answer": "Common use cases for Qdrant include:\n\n1. **Semantic Search**: Building a semantic search engine that returns relevant text pieces based on user queries, even if the words don't match exactly. This involves embedding documents into vectors and using Qdrant to find similar document vectors [source1__0021].\n\n2. **Anomaly Detection**: Embedding data points to identify outliers by distance, which is useful for fraud detection [source1__0031].\n\n3. **Multimedia Search**: Searching for images or audio by their embeddings, allowing for similarity searches across different media types [source1__0031].\n\n4. **Hybrid Filtering on User Preferences**: Implementing searches that combine geographic filtering with similarity searches, leveraging Qdrant's payload filtering capabilities [source1__0031].\n\n5. **Graph Data as Vectors**: Storing knowledge graphs or graph embeddings to find related entities, combining structured graph relations with vector similarity [source1__0031]. \n\nThese use cases highlight Qdrant's versatility in handling various types of data and search requirements.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0031", "source1__0053", "source1__0056"], "latency_ms": 10699.2, "format_valid": true, "citation_count": 5, "citation_coverage": true, "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly ", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "OK"}
{"test_id": "q19", "question": "What must all vectors in a Qdrant collection share?", "expected_points": ["same dimension", "same metric"], "answer": "All vectors in a Qdrant collection must share the same configuration, which includes the vector size (dimensionality) and the distance metric used for similarity [source1__0009].", "retrieved_chunk_ids": ["source1__0021", "source1__0009", "source1__0050", "source1__0054", "source1__0052"], "latency_ms": 4902.6, "format_valid": true, "citation_count": 1, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q20", "question": "How does filtering improve search?", "expected_points": ["refine results", "business constraints"], "answer": "Filtering improves search by allowing users to narrow down results based on specific conditions, such as categories or attributes, which enhances the relevance of the results. For instance, in Qdrant, you can filter search results to include only those that match certain criteria, like a specific city or date range, thereby eliminating irrelevant matches and focusing on the most pertinent items. This capability is particularly useful in semantic search, where results can be conceptually related but not explicitly matching the query terms. By applying filters, users can refine their search results without losing the benefits of semantic matching, leading to higher quality and more relevant outcomes [source1__0016][source1__0024]. Additionally, Qdrant's efficient filtering during the approximate nearest neighbor (ANN) search minimizes overhead, allowing for quick retrieval of filtered results even from large datasets [source1__0017].", "retrieved_chunk_ids": ["source1__0016", "source1__0023", "source1__0024", "source1__0026", "source1__0017"], "latency_ms": 8319.2, "format_valid": true, "citation_count": 3, "citation_coverage": true, "context_hit": false, "retrieved_text_preview": ["Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q01", "question": "What is Qdrant?", "expected_points": ["vector database", "embeddings"], "answer": "Qdrant is a powerful vector search engine designed for applications that require semantic understanding of data at scale. It excels in scenarios like semantic search, LLM augmentation, and recommendations, providing fast and filterable results. Qdrant is open-source, allowing for flexible deployment and integration, and is particularly effective when relevant results are prioritized over exact keyword matches.", "retrieved_chunk_ids": ["source1__0021", "source1__0005", "source1__0026", "source1__0006", "source1__0056"], "latency_ms": 6736.5, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0056"], "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "OK"}
{"test_id": "q02", "question": "How does Qdrant store data?", "expected_points": ["vectors", "payload"], "answer": "Qdrant stores data by embedding documents into vectors using models like SentenceTransformers or OpenAI's embeddings. These vectors are stored in a Qdrant collection along with payloads that include the original text and possibly metadata such as titles or sources. It is recommended to store identifiers and short snippets in Qdrant, while fetching full data from a separate store when needed, as Qdrant is not designed for large blob storage.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0027", "source1__0036"], "latency_ms": 7140.5, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0021", "source1__0053"], "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "ystems also do a second vector search using parts of the initial answer to find more info (feedback loop). Qdrant can ha", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "OK"}
{"test_id": "q03", "question": "What is a collection in Qdrant?", "expected_points": ["collection", "vectors"], "answer": "A collection in Qdrant is like a table in a relational database; it holds a set of vectors (called 'points' in Qdrant terminology) with the same configuration. When creating a collection, you specify the vector size (dimensionality) and the distance metric to use for similarity, such as cosine, dot product, or Euclidean (L2) distance.", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0009", "source1__0006", "source1__0020"], "latency_ms": 6188.8, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0009"], "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel"], "bucket": "OK"}
{"test_id": "q04", "question": "How is similarity measured in Qdrant?", "expected_points": ["cosine", "distance"], "answer": "Similarity in Qdrant is typically measured using a distance metric, such as cosine similarity or dot product. When querying for nearest neighbors, Qdrant returns a list of scored points, each with a similarity score that indicates how close the points are in the vector space. The scores can vary based on the chosen metric, with cosine similarity values ranging between -1 and 1.", "retrieved_chunk_ids": ["source1__0013", "source1__0028", "source1__0052", "source1__0015", "source1__0031"], "latency_ms": 6665.1, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0015", "source1__0028"], "context_hit": true, "retrieved_text_preview": ["Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly "], "bucket": "OK"}
{"test_id": "q05", "question": "What is Qdrant used for?", "expected_points": ["semantic search", "recommendation"], "answer": "Qdrant is used for serious applications such as semantic search, where it helps return relevant pieces of text from documents based on user queries. It excels in scenarios requiring speed and accuracy, like real-time recommendations and anomaly detection on streaming data. Additionally, Qdrant can handle dynamic data, allowing for the addition and updating of vectors on the fly while serving queries with low latency.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0005", "source1__0006", "source1__0053"], "latency_ms": 6613.0, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0021", "source1__0005"], "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or"], "bucket": "OK"}
{"test_id": "q06", "question": "What algorithm does Qdrant use for similarity search?", "expected_points": ["HNSW", "approximate nearest neighbor search"], "answer": "INSUFFICIENT_CONTEXT", "retrieved_chunk_ids": ["source1__0021", "source1__0052", "source1__0024", "source1__0028", "source1__0013"], "latency_ms": 4554.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "citations": [], "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Bonus – real-time updates: If your knowledge source updates (new documents or data coming in), Qdrant can ingest those o", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q07", "question": "What are points in Qdrant composed of?", "expected_points": ["vector", "payload"], "answer": "Points in Qdrant are composed of vectors that represent the embedded data, along with a payload that contains the original text and possibly metadata such as title or source. Each point is identified by an ID and can be updated or deleted as needed.", "retrieved_chunk_ids": ["source1__0026", "source1__0021", "source1__0020", "source1__0013", "source1__0054"], "latency_ms": 5687.8, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0021", "source1__0013"], "context_hit": true, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "client.delete(\n    collection_name=\"my_collection\",\n    points_selector=FilterSelector(\n        filter=Filter(must=[Fiel", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "OK"}
{"test_id": "q08", "question": "What can payload in Qdrant store?", "expected_points": ["metadata", "filters"], "answer": "In Qdrant, the payload can store metadata associated with each vector, such as the actual text of documents, titles, sources, or any other relevant information. It is advisable to keep the payload size manageable, ideally containing kilobytes of JSON per point, rather than large blobs of text.", "retrieved_chunk_ids": ["source1__0053", "source1__0021", "source1__0026", "source1__0052", "source1__0003"], "latency_ms": 5766.0, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0053", "source1__0021"], "context_hit": true, "retrieved_text_preview": ["an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN"], "bucket": "OK"}
{"test_id": "q09", "question": "Why use a vector database like Qdrant?", "expected_points": ["semantic search", "embeddings based retrieval"], "answer": "Qdrant is a high-performance, open-source vector database designed for real-time applications that require fast and accurate similarity search on large datasets. It excels in scenarios like semantic search, RAG pipelines, and recommendations, where traditional databases struggle with high-dimensional vector math. Additionally, Qdrant offers advanced features such as HNSW tuning and efficient filtering, making it a reliable choice for AI-driven applications.", "retrieved_chunk_ids": ["source1__0021", "source1__0002", "source1__0032", "source1__0050", "source1__0036"], "latency_ms": 7211.7, "format_valid": true, "citation_count": 3, "citation_coverage": true, "citations": ["source1__0032", "source1__0002", "source1__0036"], "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Traditional databases (SQL, NoSQL, etc.) struggle with this task – they aren’t optimized for the math of high-dimensiona", "– essentially any time you can represent something as a vector and you want to find similar ones, a vector DB is your fr", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q10", "question": "How do you choose a distance metric in Qdrant?", "expected_points": ["cosine", "Euclidean or dot"], "answer": "When creating a collection in Qdrant, you choose a distance metric that matches how your embeddings were trained. Qdrant supports popular metrics such as cosine, dot product, and Euclidean (L2) distance. The selection of the metric should align with the similarity measure used during the model training phase, for example, using cosine similarity if that was used in training.", "retrieved_chunk_ids": ["source1__0005", "source1__0009", "source1__0036", "source1__0003", "source1__0021"], "latency_ms": 6238.5, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0009"], "context_hit": false, "retrieved_text_preview": ["with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q11", "question": "How can you filter search results in Qdrant?", "expected_points": ["payload filter", "field conditions"], "answer": "You can filter search results in Qdrant by using payload filtering, which allows you to specify conditions that the results must meet. For example, you can create a filter that only retrieves vectors where a certain field, like 'city', matches a specific value, such as 'London'. This is done by constructing a Filter object with conditions that can include exact matches, ranges, and more. Qdrant efficiently applies these filters during the search process, ensuring that only relevant results are returned.", "retrieved_chunk_ids": ["source1__0021", "source1__0024", "source1__0016", "source1__0003", "source1__0026"], "latency_ms": 7859.7, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0016", "source1__0003"], "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "Speed and Performance: Qdrant uses the HNSW algorithm (Hierarchical Navigable Small World graphs) under the hood for ANN", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q12", "question": "What is the purpose of a payload index?", "expected_points": ["faster filtering", "index on payload field"], "answer": "The purpose of a payload index in Qdrant is to create a structured index (like a b-tree or inverted index) on payload data to speed up filters. This can dramatically improve filtered query latency and reduce CPU usage, at the cost of some RAM to hold the index.", "retrieved_chunk_ids": ["source1__0026", "source1__0053", "source1__0052", "source1__0016", "source1__0023"], "latency_ms": 5977.4, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0052"], "context_hit": false, "retrieved_text_preview": ["Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q13", "question": "What languages or APIs does Qdrant support?", "expected_points": ["REST API", "Python client (others)"], "answer": "Qdrant offers both RESTful HTTP API and gRPC API out of the box, along with client libraries in multiple languages including Python, TypeScript/JS, Go, Java, and Rust.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0004", "source1__0005", "source1__0056"], "latency_ms": 5353.2, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0004"], "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "arity with keyword search by allowing sparse vectors (like TF-IDF or BM25 weights) in the same index‍. This gives you th", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q14", "question": "How does Qdrant handle updates to vectors?", "expected_points": ["upsert", "reindex existing ID"], "answer": "Qdrant allows for updating vectors by re-embedding some text with a new model or deleting vectors when necessary, such as removing a discontinued product from recommendations. This flexibility enables applications to adapt to changing data while maintaining performance.", "retrieved_chunk_ids": ["source1__0054", "source1__0021", "source1__0017", "source1__0005", "source1__0050"], "latency_ms": 5670.9, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0017"], "context_hit": false, "retrieved_text_preview": ["riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I", "with new features (e.g. quantization for compression, distributed clustering, etc.) and performance improvements in each", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q15", "question": "What does similarity search return?", "expected_points": ["nearest neighbors", "score or distance"], "answer": "Similarity search returns a list of scored points, each with an ID, the similarity score (or distance), and any payload if requested. This allows users to find the most similar points in a collection based on a new vector, such as an embedding of a user query or an item.", "retrieved_chunk_ids": ["source1__0023", "source1__0015", "source1__0013", "source1__0052", "source1__0026"], "latency_ms": 6054.0, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0026"], "context_hit": false, "retrieved_text_preview": ["- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "content_copy\nCopy\nFound ID 4 with score 1.362, payload=None\nFound ID 1 with score 1.273, payload=None\nFound ID 3 with sc", "Qdrant supports batch inserts. In fact, the client’s upload_points or upload_collection can take large lists and will in", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q16", "question": "What type of database is Qdrant categorized as?", "expected_points": ["open-source", "vector database"], "answer": "Qdrant is categorized as a vector database, which is designed specifically for handling vector similarity search and related tasks. It is more robust and feature-rich than a bare library, making it suitable for various applications, especially those involving AI.", "retrieved_chunk_ids": ["source1__0021", "source1__0036", "source1__0058", "source1__0057", "source1__0040"], "latency_ms": 6255.9, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0058"], "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "with relational data, doing it in Postgres might simplify the pipeline (no need to merge results from an external servic", "t significant cost and loss of open-source freedom.\n\nIn our experience, though, Qdrant is a fantastic middle ground for ", "And when might Qdrant not be ideal? If your use case is very small or simple, and you don’t want any external service, a", "When to choose Qdrant: For most application services where queries and updates happen online, Qdrant offers a lot more c"], "bucket": "OK"}
{"test_id": "q17", "question": "Can Qdrant be run embedded in a script?", "expected_points": ["embedded mode", "in-memory or file-based"], "answer": "INSUFFICIENT_CONTEXT", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0053", "source1__0006", "source1__0054"], "latency_ms": 4513.4, "format_valid": true, "citation_count": 0, "citation_coverage": false, "citations": [], "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Getting Started with Qdrant\nReady to try Qdrant? In this section, we’ll show you how to set up Qdrant both locally and v", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q18", "question": "What are common use cases for Qdrant?", "expected_points": ["RAG", "recommendations"], "answer": "Common use cases for Qdrant include semantic search, where it helps return relevant text even if the words don't match exactly, anomaly detection for identifying outliers in data, multimedia search for finding similar images or audio, and hybrid filtering based on user preferences. It can also be used to store graph data as vectors to find related entities.", "retrieved_chunk_ids": ["source1__0021", "source1__0026", "source1__0031", "source1__0053", "source1__0056"], "latency_ms": 7015.3, "format_valid": true, "citation_count": 3, "citation_coverage": true, "citations": ["source1__0021", "source1__0031", "source1__0056"], "context_hit": true, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "Also, Qdrant being real-time means you can update vectors as user tastes change or new items arrive. If a user suddenly ", "an help maximize throughput. The Python client is synchronous by default, but you can use the REST API asynchronously or", "Closing Thoughts\nQdrant is a powerful addition to the AI developer’s toolkit. It shines when you need a production-ready"], "bucket": "OK"}
{"test_id": "q19", "question": "What must all vectors in a Qdrant collection share?", "expected_points": ["same dimension", "same metric"], "answer": "All vectors in a Qdrant collection must share the same configuration, which includes the vector size (dimensionality) and the distance metric used for similarity.", "retrieved_chunk_ids": ["source1__0021", "source1__0009", "source1__0050", "source1__0054", "source1__0052"], "latency_ms": 6078.0, "format_valid": true, "citation_count": 1, "citation_coverage": true, "citations": ["source1__0009"], "context_hit": false, "retrieved_text_preview": ["Real-World Use Cases\nQdrant isn’t just a toy for searching random numbers – it’s used in serious applications. Let’s loo", "Using Qdrant with Python\nWe’ll go through the typical operations you’d do in a vector database: creating a collection, i", "r search is a side feature, PGVector could work. If you’re building something like a semantic CMS or knowledge graph wit", "riodic index optimization (compactification). Qdrant may fragment data on disk after many deletions; currently, I believ", "iple “should” clauses (one for vector similarity, one for keyword) in a single query DSL. For example, you might require"], "bucket": "WRONG_CONTEXT"}
{"test_id": "q20", "question": "How does filtering improve search?", "expected_points": ["refine results", "business constraints"], "answer": "Filtering improves search by allowing users to narrow down results based on specific conditions, such as category or date, which enhances the relevance of the results. For instance, in Qdrant, you can filter search results to include only those that match certain criteria, like a specific city or year, thus avoiding irrelevant matches and improving the overall quality of the search results. This capability is particularly useful in semantic search, where it helps to maintain the balance between semantic relevance and specific keyword matches.", "retrieved_chunk_ids": ["source1__0016", "source1__0023", "source1__0024", "source1__0026", "source1__0017"], "latency_ms": 6940.3, "format_valid": true, "citation_count": 2, "citation_coverage": true, "citations": ["source1__0016", "source1__0024"], "context_hit": false, "retrieved_text_preview": ["Metadata Filtering in Queries\nWhat if you don’t want all similar vectors, but only those matching some condition? For ex", "- Query time: Take the user’s query string, embed it with the same model to get a query vector. Call client.search(colle", "With Qdrant, you can also add filters. Maybe the user only wants results from 2023 or later – if your payload has a year", "Data ingestion: Suppose you have a company handbook PDF or a product documentation site. Use a pipeline (maybe with a to", "The beauty is Qdrant performs this filtering efficiently during the ANN search, thanks to its filterable index design. I"], "bucket": "WRONG_CONTEXT"}
